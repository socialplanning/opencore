Formlite. 

It's getting fatter.

   >>> from opencore.browser.formhandler import FormLite, action
   >>> def decorator(func):
   ...     def inner(self):
   ...         print "in decorator"
   ...         return func(self)
   ...     return inner
   >>> def better(func):
   ...     def myinner(self):
   ...         print "in better"
   ...         return func(self)
   ...     myinner.__name__ = func.__name__
   ...     return myinner

   >>> class FormTest(FormLite):
   ...     request = type('request', (object,), dict(form={}))()
   ...     @action('roklok', default=True)
   ...     def do_roklok(self):
   ...         print "Rock!"
   ...         
   ...     @action('sod')    
   ...     def do_sign_of_devil(self):
   ...         print "eggs of the devil!"
   ...     
   ...     @action('yes1')
   ...     @decorator
   ...     def broken(self):
   ...         print "yes!!"
   ...         
   ...     @action('yes3', apply=(decorator, decorator))
   ...     def notbroken(self):
   ...         print "fine!"
   ...         
   ...     @action('yes2')
   ...     @better
   ...     def fixed(self):
   ...         print "okay!"

   >>> view = FormTest()

The dispatch methods are loaded into a dictlike object::

   >>> pprint(view.actions)
   {'roklok': <opencore.browser.formhandler.Action object at ...>,
    'sod': <opencore.browser.formhandler.Action object at ...>}

The dispatcher is dumb as a rock.  Whatever action it finds first, it executes::

   >>> view.request.form['sod']=True
   >>> view.handle_request()
   eggs of the devil!
   
   >>> del view.request.form['sod']

A request with no actions will pass without incident, unless you
set a default action::

   >>> view.handle_request()
   Rock!

The __name__ of the method decorated with @action is used in a getattr
to find the method to call, so the outermost decorator before @action
is responsible for ensuring that the __name__ of the function it
returns is identical to that of the underlying method::

   >>> view.request.form['yes1']=True
   >>> view.handle_request()
   Traceback (most recent call last):
   ...
   AttributeError: 'FormTest' object has no attribute 'inner'

   >>> del view.request.form['yes1']
   >>> view.request.form['yes2']=True
   >>> view.handle_request()
   in better
   okay!

Alternatively you can pass a decorator or a tuple of decorators
to the action decorator in the `apply' argument. These decorators
will be applied to the method before it is called on dispatch,
and the decorators do not have to worry about setting __name__.

   >>> view.request.form['yes3']=True
   >>> view.handle_request()
   in decorator
   in decorator
   fine!

This also means that your methods to be decorated *if and only if*
they are called by dispatch; when called directly the methods will
not be decorated::

   >>> view.notbroken()
   fine!

And all methods still work as normal::

   >>> view.do_roklok()
   Rock!


